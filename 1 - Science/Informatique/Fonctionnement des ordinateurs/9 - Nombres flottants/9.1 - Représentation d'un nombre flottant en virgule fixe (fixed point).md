---
## Metadata
tags : 
 - Note_done Note_WIP Informatique
 - 
source : UMons - Fonctionnement des ordinateurs
---

Link :
_Fonctionnement des ordinateurs : Représentation des nombres naturels & entiers_
1. [[../2 - Représentation des nombres naturels & entiers/2.3 - Notation positionnelle généralisée|2.3 - Notation positionnelle généralisée]]
2. [[../2 - Représentation des nombres naturels & entiers/2.3.1 - Représentation décimale|2.3.1 - Représentation décimale]]
3. [[../2 - Représentation des nombres naturels & entiers/2.3.2 - Représentation binaire|2.3.2 - Représentation binaire]]
4. [[../2 - Représentation des nombres naturels & entiers/2.3.2.1 - Bit|2.3.2.1 - Bit]]

_Fonctionnement des ordinateurs : Caractères & Chaînes de caractères_
1.

_Fonctionnement des ordinateurs : Eléments de conception logique_
1.

_Fonctionnement des ordinateurs : Processeur_
1.

_Fonctionnement des ordinateurs : Micro-architecture_
1.

_Fonctionnement des ordinateurs : Assemblage & Compilation_
1.

_Fonctionnement des ordinateurs : Hiérarchie de mémoires_
1.

_Fonctionnement des ordinateurs : Nombres flottants_
1.

**Introduction** : Au delà de la représentation des entiers ? 
Jusqu'à présent, nous nous sommes focalisés sur la représentation de nombres entiers. Comment étendre cette représentation aux nombres réels ? 
\
_Méthodologie_ : 
1. Nous allons commencer par aborder la représentation en virgule fixe, une extension simple de la représentation entière que nous avons vue jusqu'ici. 
2. Ensuite, nous passerons à la représentation en virgule flottante, représentation supportée par la plupart des processeurs modernes. Nous nous intéresserons en particulier au standard IEEE 754. 

_Limites_ :
Finalement, nous identifierons un certain nombre de limites de la représentation en virgule flottante qu'un informaticien / mathématicien doit absolument comprendre

# Définition
Dans la représentation en virgule fixe, une séquence $w$ de $N+M$ bits est utilisée :
- $N$ bits de poids fort représentent la $\color{red}\text{partie entière}$ 
- $M$ bits de poids faible représentent la $\color{green}\text{partie fractionnelle}$ 

**Illustration** : $$w={\color{red}w_{N-1}\cdots w_0}\underbrace{}_{\text{Position de la virgule}}{\color{green}w_{-1}\cdots w_{-M}}$$
Le nombre $x$ représenté (binaire $\to$ décimal) est obtenu par $$x=\sum^{N-1}_{i=-M}w_i.2^i$$ Nous ne représentons que des nombres positifs, mais il est aisé de modifier la représentation pour supporter les nombres négatifs. En effet, chaque bit de la partie fractionnelle a un poids égal à une fraction fixe dont le dénominateur est un exposant de 2.
**Illustration** : ![[../../../../0 - Dossier Template/Dossier IMage/Pasted image 20240429121636.png]]
#### Exemple
Avec $\color{red}N=8$ pour la partie entière et $\color{green}M=4$ pour la partie fractionnelle, que représente le mot $w = {\color{red}01001100}{\color{green}0011}$ ? $$\begin{aligned}x&={\color{red}2 ^6+2^3+2 ^2}+{\color{green}2^{-3}+2^{-4}}\\&={\color{red}64+8+4}+{\color{green}\frac{1}{8}+\frac{1}{16}}\\&=76,1875\end{aligned}$$
### Algorithme - Conversion partie fractionnelle en binaire
Hypothèse : $$0\le x < 1$$multiplications successives par 2 + test de la partie entière
```python
w = "" 
bits = 0 
while x > 0 and bits < M: 
	x = x * 2 
	bits += 1 
	if int(x) > 0: # retourne la partie entière
		x = x – 1 
		w = w + "1" 
	else: 
		w = w + "0"
```
On a que `bits = 0`, `bits < M` et `bits += 1` qui limite le nombre de bits de la représentation
**Illustration** : ![[../../../../0 - Dossier Template/Dossier IMage/Pasted image 20240429122453.png]]
## Propriété 1
Il est possible de ré-organiser sensiblement l'équation précédente afin d'exprimer le nombre représenté sous forme d'une fraction dont le dénominateur est fixé : $$\begin{aligned}x&=\sum^{N-1}_{i=-M}w_i.2^i\\&=\sum^{N+M-1}_{i= 0}w_{i-M}.2^{i-M}\\&=\frac{1}{{\color{orange}2^M}}.\left({\color{purple}\sum^{N+M-1}_{i=0}w_{i-M}.2^{i}}\right)\\&={\color{purple}m}.{\color{orange}2^{-M}}\end{aligned}$$ où
1. ${\color{purple}\sum^{N+M-1}_{i=0}w_{i-M}.2^{i}}$ : Numérateur variable appelé la “mantisse” ($\color{purple}m$) représenté sur $N+M$ bits
2. ${\color{orange}2^M}$ : Dénominateur fixe dépendant uniquement de $M$ 

\
_Remarque_ :
1. la valeur de $M$ (fixe) dicte quelle est la “position de la virgule"

#### Exemple
Avec $\color{red}N=8$ pour la partie entière et $\color{green}M=4$ pour la partie fractionnelle, que représente le mot $w = {\color{red}01001100}{\color{green}0011}$ ? $$\begin{aligned}
\text{x=}& \frac{1}{2^M}.\left(\sum_{i=0}^{N+M-1}w_{i-M}.2^i\right)  \\
\text{=}& \frac1{2^4}.\left({\color{red}2^{10}+2^7+2^6}+{\color{green}2^1+2^0}\right)  \\
=& \frac{1024+128+64+2+1}{16}  \\
\text{=}& \frac{1219}{16}  \\
\text{=}& \text{76,1875} 
\end{aligned}$$
## Propriété 2 - Limites de représentabilité
Etant donnés $N$ et $M$, on a que :
- Limites de représentabilité : $$\frac{2^{N+M}-1}{2^M}$$ (où tous les bits valent 1)
- Plus petit nombre non-nul représentable : $$\frac{1}{2^M}$$ (Seul le bit de poids le plus faible vaut 1) et c’est aussi le plus petit écart entre deux nombres représentables exactement.

#### Exemple : avec $N=8$ et $M=4$ 
1. Plus grand = 255,9375 i.e. ${\color{red}11111111}{\color{green}1111}$ 
2. Plus petit = 0,0625 i.e. ${\color{red}00000000}{\color{green}0001}$ 

### Inconvénient 
La représentation en virgule fixe ne permet pas de représenter tous les nombres réels dans un intervalle, comme cela était possible pour les entiers.
\
Il existe une infinité de réels entre deux entiers alors que pour une taille de mots $N+M$, il est possible de représenter seulement $2^{N+M}$ nombres différents !
