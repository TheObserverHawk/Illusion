---
## Metadata
tags : 
 - Note_done Note_WIP Informatique
 - 
source : UMons - Fonctionnement des ordinateurs
---

Link :
_Fonctionnement des ordinateurs : Représentation des nombres naturels & entiers_
1. [[../2 - Représentation des nombres naturels & entiers/2.3 - Notation positionnelle généralisée|2.3 - Notation positionnelle généralisée]]
2. [[../2 - Représentation des nombres naturels & entiers/2.3.1 - Représentation décimale|2.3.1 - Représentation décimale]]
3. [[../2 - Représentation des nombres naturels & entiers/2.3.2 - Représentation binaire|2.3.2 - Représentation binaire]]
4. [[../2 - Représentation des nombres naturels & entiers/2.3.2.1 - Bit|2.3.2.1 - Bit]]

_Fonctionnement des ordinateurs : Caractères & Chaînes de caractères_
1.

_Fonctionnement des ordinateurs : Eléments de conception logique_
1.

_Fonctionnement des ordinateurs : Processeur_
1.

_Fonctionnement des ordinateurs : Micro-architecture_
1.

_Fonctionnement des ordinateurs : Assemblage & Compilation_
1.

_Fonctionnement des ordinateurs : Hiérarchie de mémoires_
1.

_Fonctionnement des ordinateurs : Nombres flottants_
1.

**Introduction** : Au delà de la représentation des entiers ? 
Jusqu'à présent, nous nous sommes focalisés sur la représentation de nombres entiers. Comment étendre cette représentation aux nombres réels ? 
\
_Méthodologie_ : 
1. Nous allons commencer par aborder la représentation en virgule fixe, une extension simple de la représentation entière que nous avons vue jusqu'ici. 
2. Ensuite, nous passerons à la représentation en virgule flottante, représentation supportée par la plupart des processeurs modernes. Nous nous intéresserons en particulier au standard IEEE 754. 

_Limites_ :
Finalement, nous identifierons un certain nombre de limites de la représentation en virgule flottante qu'un informaticien / mathématicien doit absolument comprendre

# Définition
Dans la représentation en virgule fixe, une séquence $w$ de $N+M$ bits est utilisée :
- $N$ bits de poids fort représentent la $\color{red}\text{partie entière}$ 
- $M$ bits de poids faible représentent la $\color{green}\text{partie fractionnelle}$ 

**Illustration** : $$w={\color{red}w_{N-1}\cdots w_0}\underbrace{}_{\text{Position de la virgule}}{\color{green}w_{-1}\cdots w_{-M}}$$
Le nombre $x$ représenté (binaire $\to$ décimal) est obtenu par $$x=\sum^{N-1}_{i=-M}w_i.2^i$$ Nous ne représentons que des nombres positifs, mais il est aisé de modifier la représentation pour supporter les nombres négatifs. En effet, chaque bit de la partie fractionnelle a un poids égal à une fraction fixe dont le dénominateur est un exposant de 2.
**Illustration** : ![[../../../../0 - Dossier Template/Dossier IMage/Pasted image 20240429121636.png]]
### Algorithme - Conversion partie fractionnelle en binaire
Hypothèse : $$0\le x < 1$$multiplications successives par 2 + test de la partie entière
```python

```