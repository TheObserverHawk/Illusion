---
## Metadata
tags : 
 - Note_done Note_WIP Informatique
 - 
source : UMons - Fonctionnement des ordinateurs
---

Link :
_Fonctionnement des ordinateurs : Représentation des nombres naturels & entiers_
1. [[2.3.2.1 - Bit]]
2. [[2.3.2.2 - Octet]]

_Fonctionnement des ordinateurs : Caractères & Chaînes de caractères_
1.

_Fonctionnement des ordinateurs : Eléments de conception logique_
1.

_Fonctionnement des ordinateurs : Processeur_
1.

_Fonctionnement des ordinateurs : Micro-architecture_
1.

_Fonctionnement des ordinateurs : Assemblage & Compilation_
1.

_Fonctionnement des ordinateurs : Hiérarchie de mémoires_
1.

**Introduction**
*Mémoire de grande taille, à faible latence et coût* : 
1. Donner l’illusion d’une mémoire de grande taille
2. Seule une partie de cette mémoire est présente à un moment donné en mémoire physique
3. Mémoire physique agit comme "cache" pour la mémoire secondaire

 *Protection des processus* :
1. Plusieurs programmes / processus sont exécutés "au même moment" par le processeur et résident donc tous en mémoire.
2. Protéger les programmes les uns des autres : un programme n’a pas accès à l’espace mémoire d’un autre (sauf si permission)
# Définition
### Définition : Pagination
Différents programmes (processus) peuvent cohabiter en mémoire sur un même ordinateur. Ces programmes ont des tailles différentes.
\
Si la mémoire est allouée de manière monolithique, c.-à-d. que l’entièreté de la mémoire nécessaire à un programme est allouée en un seul bloc, des situations de fragmentation de la mémoire peuvent mener à l’impossibilité de charger un programme en mémoire
**Illustration** : ![[IMG_5296.jpeg]]
Pour pallier ce problème, la mémoire est découpée en petits blocs de même taille appelés **pages**. Chaque programme reçoit les pages qui lui sont nécessaires
## Architecture générale de la mémoire virtuelle
![[IMG_5297.jpeg]]
La mémoire est découpée en **pages** de même taille. La taille typique d’une page est $$4\text{ KB }\left(\text{ i.e. } 4.10^3\text{ B }=4.2^{10}=2^{12}\text{ B }\right)$$
1. La **mémoire physique** contient des pages physiques. Chaque page physique a une adresse physique.
2. La **mémoire virtuelle** contient des pages virtuelles. Chaque page virtuelle a une adresse virtuelle.

Il y a plus de pages virtuelles que de pages physiques. Les adresses virtuelles sont donc plus longues que les adresses physique. Une page virtuelle peut être dans deux états différents : 
1. **active** : chargée en mémoire physique – il y a alors correspondance entre cette page virtuelle et une page physique
2. **inactive** : réside en mémoire secondaire (p.ex. disque dur ou SSD

### Traduction d’adresses dans la mémoire virtuelle 
La correspondance entre une adresse virtuelle et une adresse physique est appelée **traduction d’adresse**.
_**Illustration**_ : ![[IMG_5298.jpeg]]
1. Une adresse virtuelle est composée d’un $\color{red}\text{numéro de page virtuel}$ (VPN = Virtual Page Number) et d’un offset dans la page
2.  Une adresse physique est composée d’un $\color{lightblue}\text{numéro de page physique}$ (PPN = Physical Page Number) et d’un offset dans la page

 La traduction ne porte que sur les VPN → PPN. Le déplacement (offset) à l’intérieur d’une page n’est pas affecté par la traduction.
### Organisation de la table des pages pour la gestion de mémoire virtuelle
 Une page virtuelle doit pouvoir être chargée à n’importe quel endroit en mémoire physique. Par conséquent un VPN doit pouvoir être traduit en n’importe quel PPN. La correspondance VPN → PPN est conservée dans une table appelée **Table des Pages** : 
1.  Contient une entrée par VPN; Le VPN sert d’index
2. Chaque entrée comprend 1 bit de validité et un PPN
3. Stockée en mémoire physique. Son emplacement est typiquement désigné par un registre spécial (page table register)

**Illustration** : ![[IMG_5308.jpeg]]
\
_Remarque_ :  
1. utiliser une mémoire spéciale pour stocker la table des pages n’est pas envisageable car le nombre de pages virtuelles est très grand 
(p.ex. 4GB ⇒ ~1M pages de 4KB)


#### Exemple
Supposons que 
1. La mémoire physique contient $\color{lightblue}64\text{ MB}$ ($2^{26}$ octets)
2. La mémoire virtuelle fait $\color{lightblue}4\text{ GB}$ ($2^{32}$ octets)
3. Chaque page fait $\color{lightblue}4\text{ KB}$ ($2^{12}$ octets)

**Illustration** : ![[IMG_5309.jpeg]]
Donc,
1. Il y a $$\frac{\text{Taille de la mémoire virtuelle}}{\text{Taille de la mémoire physique}}=4 GB / 4 KB =\frac{2^{32}}{2^{12}}= 1 \text{M de pages virtuelles } \left(2^{20}\right)$$
2. Une adresse physique fait 26 bits (14 pour le PPN, 12 pour l’offset).
3. Une adresse virtuelle fait 32 bits (20 pour le VPN, 12 pour l’offset).
4. Chaque entrée de la table des pages contient : $$\text{1 bit de validité + 14 bits de PPN}$$Pour simplifier, on considère 2 octets ($2\text{B}=16\text{b}$) par entrée.
6. Il y a $2^{20}$ entrées (= nombre de pages virtuelles)
7. La taille totale de la table des pages est de $$\text{Contenu d’une entrée de la table des pages . Nombres de pages virtuelles }=2 \text{ octets } . 2^{20} = 2.2^{20}= 2\text{MB}$$, ce qui occupe $$\frac{\text{Taille totale de la table de pages}}{\text{Taille de la mémoire physique}}=\frac{2 \text{MB }}{4 \text{KB} }= 512 \text{ pages }$$

#### Comment la correspondance entre adresses virtuelles et adresses physiques fonctionnent ?
Pour chaque accès mémoire, le processus de traduction est le suivant :
1) Le processeur extrait le $\color{red}\text{VPN}$ de l’$\color{red}\text{adresse virtuelle}$
2) Il consulte la $\colortable de pages pour obtenir le PPN, en utilisant le VPN
comme index (nécessite un accès mémoire)
3) Si l’entrée est invalide, une exception Page Fault est déclenchée.
● Le gestionnaire associé charge la page virtuelle depuis la 
mémoire secondaire (p.ex. disque dur).
● La page des tables est mise à jour.
4) Il complète le PPN avec l’offset pour obtenir l’adresse physique
5) La lecture ou l’écriture à l’adresse physique peut alors avoir