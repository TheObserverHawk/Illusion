---
## Metadata
tags : 
 - Note_done Note_WIP Informatique
 - 
source : UMons - Fonctionnement des ordinateurs
---

Link :
_Fonctionnement des ordinateurs : Représentation des nombres naturels & entiers_
1.

_Fonctionnement des ordinateurs : Caractères & Chaînes de caractères_
1.

_Fonctionnement des ordinateurs : Eléments de conception logique_
1.

_Fonctionnement des ordinateurs : Processeur_
1.

_Fonctionnement des ordinateurs : Micro-architecture_
1.

_Fonctionnement des ordinateurs : Assemblage & Compilation_
1.

_Fonctionnement des ordinateurs : Hiérarchie de mémoires_
1.

# Définition
Le simulateur SPIM permet aux programmes qu’il exécute d’interagir avec l’utilisateur au travers d’une console. Pour cela, il est possible d’effectuer la lecture ou l’écriture de données de et vers la console : entiers, flottants et chaînes de caractères. 
\
Ces interactions sont réalisées à l’aide d’ ≪ **appels systèmes** ≫ qu’un programme en langage d’assemblage MIPS peut invoquer. Les appels systèmes supportés par SPIM sont résumés à la table suivante :

| Service        | Numéro de l’appel système | Arguments                                             | Résultats            |
| -------------- | ------------------------- | ----------------------------------------------------- | -------------------- |
| `print int`    | 1                         | `$a0` = integer                                       |                      |
| `print float`  | 2                         | `$f12` = float                                        |                      |
| `print double` | 3                         | `$f12` = double                                       |                      |
| `print string` | 4                         | `$a0` = string                                        |                      |
| `read int`     | 5                         |                                                       | Integer (dans `$v0`) |
| `read float`   | 6                         |                                                       | Float (dans `$f0`)   |
| `read double`  | 7                         |                                                       | Double (dans `$f0`)  |
| `read  string` | 8                         | `$a0` = adresse du buffer, `$a1` = longueur du buffer |                      |
| `sbrk`         | 9                         | `$a0` = quantité                                      | address (dans `$v0`) |
| `exit`         | 10                        |                                                       |                      |
| `print char`   | 11                        | `$a0` = char                                          |                      |
| `read char`    | 12                        |                                                       | char (dans `$v0`)    |
Pour invoquer un appel système, l’instruction spéciale `syscall` est utilisée. Cette instruction n’a pas d’opérande. Ses arguments sont passés au travers de registres. Le numéro de l’appel système est toujours passé dans le registre `v0`. 
\
Chaque appel système transfère ses autres arguments ainsi que ses résultats dans des registres qui varient d’un appel système à l’autre et qui sont documentés à la Table ci-dessus respectivement dans les colonnes ≪ Arguments ≫ et ≪ Résultats  ≫. 
\
Par exemple, l’appel système n°1 affiche un entier à la console. L’entier à afficher doit être passé dans le registre `a0`. A l’opposé, l’appel système n°5 lit un entier à partir de la console. L’entier résultant est récupéré dans le registre `v0`

#### Exemple : Addition de 2 entiers (MIPS)
```MIPS
  .text
main:
  addiu $sp, $sp, -4
  sw $ra, 0($sp)
  li $a0, 5
  li $a1, 4
  jal sum
  lw $ra, 0($sp)
  addiu $sp, $sp, 4
  jr $ra

sum:
  add $a0, $a0, $a1
  li $v0, 1
  syscall
  jr $ra
```
`li $v0, 1` + `syscall` donne à la console le résultat de l'addition (i.e. 9) de deux entiers, i.e. 5 et 4,  